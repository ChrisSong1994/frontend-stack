# 正则表达式使用

在 JavaScript 中，正则表达式（RegExp）是处理字符串匹配、替换和提取的强大工具。以下是其核心用法、语法及实际场景的完整指南：

---

### 一、创建正则表达式
JavaScript 提供两种创建正则的方式：

#### 1. **字面量形式**（推荐）
直接使用 `/pattern/flags` 语法：
```javascript
// 匹配所有数字，忽略大小写（无意义但演示 flags）
const numRegex = /\d+/gi; 
```

#### 2. **构造函数形式**
动态构建正则时使用，需转义反斜杠：
```javascript
// 匹配邮箱地址
const emailRegex = new RegExp('^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$', 'i');
```

---

### 二、核心方法及使用

#### 1. **RegExp 对象方法**
| 方法       | 作用                           | 示例                                  |
|------------|--------------------------------|---------------------------------------|
| `test()`   | 检测字符串是否匹配，返回布尔值 | `/\d+/.test('abc123')` → `true`      |
| `exec()`   | 返回匹配结果的数组（含分组）   | `/\d+/.exec('abc123')` → `['123']`   |

#### 2. **String 对象方法**
| 方法          | 作用                           | 示例                                      |
|---------------|--------------------------------|-------------------------------------------|
| `match()`     | 返回所有匹配结果数组           | `'a1b2'.match(/\d/g)` → `['1', '2']`     |
| `replace()`   | 替换匹配内容                   | `'Hello'.replace(/l/gi, '*')` → `'He**o'`|
| `search()`    | 返回首个匹配的索引             | `'abc123'.search(/\d/)` → `3`            |
| `split()`     | 按正则分割字符串为数组         | `'a,b;c'.split(/[,;]/)` → `['a','b','c']`|

---

### 三、正则语法详解

#### 1. **修饰符（Flags）**
| 修饰符 | 作用                          |
|--------|-------------------------------|
| `g`    | 全局匹配（查找所有匹配项）    |
| `i`    | 忽略大小写                    |
| `m`    | 多行模式（^/$ 匹配行首尾）   |
| `u`    | 启用 Unicode 模式             |
| `y`    | 粘连匹配（从上次结束位置开始）|

#### 2. **元字符与量词**
| 符号     | 含义                          | 示例                  |
|----------|-------------------------------|-----------------------|
| `.`      | 匹配任意单个字符（换行除外）  | `a.c` → "abc", "a c" |
| `\d`     | 数字（等价于 `[0-9]`）        | `\d+` → "123"        |
| `\w`     | 单词字符（字母、数字、下划线）| `\w+` → "user123"    |
| `^` / `$`| 匹配字符串开始/结束           | `^A.*z$` → "Abcxyz"  |
| `[abc]`  | 匹配括号内任意字符            | `[aeiou]` → "e"      |
| `{n,m}`  | 匹配次数范围（n次到m次）      | `a{2,4}` → "aaa"     |

#### 3. **分组与捕获**
• **捕获组**：用 `()` 包裹，按顺序编号：
  ```javascript
  const dateStr = '2023-10-05';
  const match = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
  console.log(match[1]); // "2023"（年）
  ```
• **非捕获组**：用 `(?:)` 避免捕获：
  ```javascript
  '1a2b'.match(/(?:\d)(\w)/g); // 只捕获字母 → ['a', 'b']
  ```

---

### 四、实用场景示例

#### 1. **表单验证**
```javascript
// 验证手机号（中国大陆）
function isValidPhone(phone) {
  return /^1[3-9]\d{9}$/.test(phone);
}
console.log(isValidPhone('13812345678')); // true
```

#### 2. **数据提取**
```javascript
// 提取 URL 中的域名
const url = 'https://www.example.com/path?query=1';
const domain = url.match(/https?:\/\/([^\/]+)/)[1]; // "www.example.com"
```

#### 3. **文本替换**
```javascript
// 隐藏手机号中间四位
const phone = '13812345678';
const masked = phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2'); // "138****5678"
```

#### 4. **复杂匹配**
```javascript
// 匹配含至少一个大写字母、数字和特殊字符的密码
const pwdRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
```

---

### 五、性能优化与陷阱

#### 1. **避免灾难性回溯**
• **问题正则**：`/(a+)+b/.test('aaaaac')`（极端情况导致超长匹配时间）
• **优化方法**：使用原子组（ES2021 引入）或具体量词：
  ```javascript
  // 使用原子组（Atomic Groups）
  const regex = /(?>a+)+b/;
  ```

#### 2. **预编译正则**
在循环中重复使用同一正则时，避免重复创建：
```javascript
// 错误：每次循环都创建新正则
for (let i = 0; i < 1000; i++) {
  /test/.test(str);
}

// 正确：预编译正则
const regex = /test/;
for (let i = 0; i < 1000; i++) {
  regex.test(str);
}
```

#### 3. **全局标志 `g` 的副作用**
使用全局匹配时，`lastIndex` 属性可能导致意外行为：
```javascript
const regex = /test/g;
regex.test('test'); // true
regex.test('test'); // false（lastIndex 已到末尾）
```

---

### 六、工具与调试
1. **在线测试工具**：
   • [RegExr](https://regexr.com/)（实时高亮匹配结果）
   • [Regex101](https://regex101.com/)（生成解释和测试用例）
2. **控制台调试**：
   ```javascript
   console.log(/pattern/.exec(str)); // 查看详细匹配信息
   ```

---

掌握这些技巧后，您能高效处理字符串操作，但需注意正则的复杂性可能影响可读性。对于超复杂逻辑，可考虑拆分处理或使用专用解析库（如解析 JSON 勿用正则）。